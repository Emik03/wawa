// SPDX-License-Identifier: MPL-2.0
namespace wawa.TwitchPlays.Internals;

/// <summary>Contains static methods able to be accessed from anywhere within this library.</summary>
static class Globals
{
    /// <summary>The default binding flags throughout the library.</summary>
    internal const BindingFlags
        Bindings = Instance | Static | Public | NonPublic | FlattenHierarchy,
        FieldBindings = Instance ^ Bindings;

    /// <summary>The default string comparison throughout the library.</summary>
    internal const StringComparison
        Ordinal = StringComparison.Ordinal,
        OrdinalIgnoreCase = StringComparison.OrdinalIgnoreCase;

    /// <summary>Field name generated by enums.</summary>
    [NotNull]
    internal const string InternalField = "__";

    [NotNull]
    const string
        Boolean = "true/false",
        CannotSerialize = $"This type lacks static fields of itself, or a {nameof(int.TryParse)} method that takes a " +
            $"{nameof(String)}, has an out parameter of itself, and returns {nameof(Boolean)}.",
        Ellipsis = "\u2026",
        Float = $"<#.#{Ellipsis}>",
        InvalidFormat = "The format was invalid.",
        NotImplemented = "Not implemented.",
        Null = "<null>",
        Signed = "<#>",
        Character = "<character>",
        Text = "<text>",
        TooShort = "There aren't enough parameters given.",
        Unsigned = "<+#>";

    /// <summary>Creates a human-friendly <see langword="string"/> representing the reason for the error.</summary>
    /// <param name="err">The error to convert.</param>
    /// <param name="type">The type that was used.</param>
    /// <returns>A human-friendly <see langword="string"/> representing the reason for the error.</returns>
    [NotNull, Pure]
    internal static string Reason([InstantHandle] this ParseError err, [NotNull] in Type type) =>
        err switch
        {
            ParseError.Empty => TooShort,
            ParseError.NoMatch => InvalidFormat,
            ParseError.Unserializable => CannotSerialize,
            ParseError.Field => $"Expected one of {string.Join(" ", [..type.DisplayFields()])}",
            _ => throw new ArgumentOutOfRangeException(nameof(err), err, NotImplemented),
        };

    /// <summary>Gets a <see cref="string"/> representation of parameters.</summary>
    /// <param name="parameters">The parameters to make a string representation of.</param>
    /// <returns>A <see cref="string"/> representation of the parameter <paramref name="parameters"/>.</returns>
    [NotNull, MustUseReturnValue]
    internal static string Show([InstantHandle, NotNull] this IEnumerable<ParameterInfo> parameters)
    {
        [NotNull]
        static string Display([AllowNull, CanBeNull] Type x) =>
            x switch
            {
                null => Null,
                _ when x.GetElementType() is { } y => $"{Display(y)} {Display(y)} {Ellipsis}",
                _ when x == typeof(bool) => Boolean,
                _ when x == typeof(char) => Character,
                _ when x == typeof(string) || x == typeof(object) => Text,
                _ when x == typeof(float) || x == typeof(double) || x == typeof(decimal) => Float,
                _ when x == typeof(byte) || x == typeof(ushort) || x == typeof(uint) || x == typeof(ulong) => Unsigned,
                _ when x == typeof(sbyte) || x == typeof(short) || x == typeof(int) || x == typeof(long) => Signed,
                _ => $"<{string.Join("/", [..x.DisplayFields()])}>",
            };

        [NotNull]
        static string Description([AllowNull, CanBeNull] ParameterInfo x) =>
            x?.ParameterType
               .GetCustomAttributes(false)
               .OfType<DescriptionAttribute>()
               .FirstOrDefault() is { Description: var description }
                ? $" ({description})"
                : "";

        return string.Join(" ", [..parameters.Select(static x => $"{Display(x.ParameterType)}{Description(x)}")]);
    }

    [NotNull, Pure] // ReSharper disable once SuggestBaseTypeForParameter
    static IEnumerable<string> DisplayFields(this Type reflect) =>
        reflect
           .GetFields(FieldBindings)
           .Where(static x => x.Name is not InternalField)
           .Select(AliasAttribute.ToString)
           .Select(static x => x.ToLowerInvariant());
}
