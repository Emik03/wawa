// <copyright file="Globals.cs" company="Emik">
// Copyright (c) Emik. This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// </copyright>
global using System.Collections.ObjectModel;
global using Emik.Optionals;
global using Emik.Unity;
global using Wawa.Modules;
global using Wawa.TwitchPlays.Domains;
global using Wawa.TwitchPlays.Internals;
global using static System.Reflection.BindingFlags;
global using static Wawa.IO.PathFinder;
global using static Wawa.TwitchPlays.Internals.Globals;

namespace Wawa.TwitchPlays.Internals;

/// <summary>Contains static methods able to be accessed from anywhere within this library.</summary>
static class Globals
{
    /// <summary>The default binding flags throughout the library.</summary>
    internal const BindingFlags
        Bindings = Instance | Static | Public | NonPublic,
        FieldBindings = Instance ^ Bindings;

    /// <summary>The default string comparison throughout the library.</summary>
    internal const StringComparison
        Ordinal = StringComparison.Ordinal,
        OrdinalIgnoreCase = StringComparison.OrdinalIgnoreCase;

    /// <summary>Field name generated by enums.</summary>
    internal const string InternalField = "__";

    const string
        Boolean = "true/false",
        CannotSerialize = $"This type lacks static fields of itself, and a {nameof(int.TryParse)} that takes a " +
            $"{nameof(String)}, has an out parameter of itself, and returns {nameof(Boolean)}.",
        Ellipsis = "\u2026",
        Float = $"<#.#{Ellipsis}>",
        InvalidFormat = "The format was invalid.",
        NotImplemented = "Not implemented.",
        Null = "<null>",
        Signed = "<#>",
        Character = "<character>",
        Text = "<text>",
        TooShort = "There aren't enough parameters given.",
        Unsigned = "<+#>";

    /// <summary>Creates a human-friendly <see langword="string"/> representing the reason for the error.</summary>
    /// <param name="err">The error to convert.</param>
    /// <param name="type">The type that was used.</param>
    /// <returns>A human-friendly <see langword="string"/> representing the reason for the error.</returns>
    [NotNull]
    internal static string Reason([InstantHandle] this ParseError err, [NotNull] in Type type) =>
        err switch
        {
            ParseError.Empty => TooShort,
            ParseError.Field => $"Expected one of {Stringifier.Conjoin(type.DisplayFields(), ' ')}",
            ParseError.NoMatch => InvalidFormat,
            ParseError.Unserializable => CannotSerialize,
            _ => throw new ArgumentOutOfRangeException(nameof(err), err, NotImplemented),
        };

    /// <summary>Gets a <see cref="string"/> representation of parameters.</summary>
    /// <param name="parameters">The parameters to make a string representation of.</param>
    /// <returns>A <see cref="string"/> representation of the parameter <paramref name="parameters"/>.</returns>
    [NotNull, Pure]
    internal static string Show([InstantHandle, NotNull] this IEnumerable<ParameterInfo> parameters)
    {
        [NotNull]
        static string Display([AllowNull, CanBeNull] Type x) =>
            x switch
            {
                null => Null,
                _ when x.GetElementType() is { } y => $"{Display(y)} {Display(y)} {Ellipsis}",
                _ when x == typeof(bool) => Boolean,
                _ when x == typeof(char) => Character,
                _ when x == typeof(string) ||
                    x == typeof(object) => Text,
                _ when x == typeof(float) ||
                    x == typeof(double) ||
                    x == typeof(decimal) => Float,
                _ when x == typeof(byte) ||
                    x == typeof(ushort) ||
                    x == typeof(uint) ||
                    x == typeof(ulong) => Unsigned,
                _ when x == typeof(sbyte) ||
                    x == typeof(short) ||
                    x == typeof(int) ||
                    x == typeof(long) => Signed,
                _ => $"<{Stringifier.Conjoin(x.DisplayFields(), '/')}>",
            };

        return Stringifier.Conjoin(parameters.Select(static x => Display(x.ParameterType)), ' ');
    }

    static IEnumerable<string> DisplayFields(this IReflect reflect) =>
        reflect
           .GetFields(FieldBindings)
           .Where(static x => x.Name is not InternalField)
           .Select(AliasAttribute.ToString)
#pragma warning disable CA1308
           .Select(static x => x.ToLowerInvariant());
#pragma warning restore CA1308
}
